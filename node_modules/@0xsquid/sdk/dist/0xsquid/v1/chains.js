"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseChainsResponse = exports.parseChainData = exports.parseCosmosChain = exports.parseEvmChain = exports.parseBaseChain = exports.parseSquidContracts = exports.parseAxelarContracts = exports.parseChainNativeContracts = void 0;
const util_1 = require("./util");
const types_1 = require("../../types");
const parseChainNativeContracts = (data) => {
    const { wrappedNativeToken, ensRegistry, multicall, usdcToken } = data;
    return { wrappedNativeToken, ensRegistry, multicall, usdcToken };
};
exports.parseChainNativeContracts = parseChainNativeContracts;
const parseAxelarContracts = (data) => {
    const { gateway, forecallable } = data;
    return (0, util_1.removeEmpty)({ gateway, forecallable });
};
exports.parseAxelarContracts = parseAxelarContracts;
const parseSquidContracts = (data) => {
    const { squidRouter, defaultCrosschainToken, squidMulticall } = data;
    return (0, util_1.removeEmpty)({ squidRouter, defaultCrosschainToken, squidMulticall });
};
exports.parseSquidContracts = parseSquidContracts;
const parseBaseChain = (data) => {
    const { chainName, chainType, rpc, internalRpc, networkName, chainId, nativeCurrency, chainIconURI, blockExplorerUrls, axelarContracts, squidContracts, estimatedRouteDuration, estimatedExpressRouteDuration } = data;
    return {
        chainName,
        chainType,
        rpc,
        internalRpc,
        networkName,
        chainId,
        nativeCurrency,
        chainIconURI,
        blockExplorerUrls,
        axelarContracts: (0, exports.parseAxelarContracts)(axelarContracts),
        squidContracts: (0, exports.parseSquidContracts)(squidContracts),
        estimatedRouteDuration,
        estimatedExpressRouteDuration
    };
};
exports.parseBaseChain = parseBaseChain;
const parseEvmChain = (data) => {
    const baseChain = (0, exports.parseBaseChain)(data);
    const { chainNativeContracts } = data;
    return {
        ...baseChain,
        chainNativeContracts: (0, exports.parseChainNativeContracts)(chainNativeContracts)
    };
};
exports.parseEvmChain = parseEvmChain;
const parseCosmosChain = (data) => {
    const baseProperties = (0, exports.parseBaseChain)(data);
    const { rest, stakeCurrency, walletUrl, walletUrlForStaking, bip44, alternativeBIP44s, bech32Config, currencies, feeCurrencies, coinType, features, gasPriceStep, chainToAxelarChannelId } = data;
    return (0, util_1.removeEmpty)({
        ...baseProperties,
        rest,
        stakeCurrency,
        walletUrl,
        walletUrlForStaking,
        bip44,
        alternativeBIP44s,
        bech32Config,
        currencies,
        feeCurrencies,
        coinType,
        features,
        gasPriceStep,
        chainToAxelarChannelId
    });
};
exports.parseCosmosChain = parseCosmosChain;
const parseChainData = (data) => {
    const chains = data
        .filter((chain) => [types_1.ChainType.EVM, types_1.ChainType.Cosmos].includes(chain.chainType))
        .map((chain) => {
        switch (chain.chainType) {
            case types_1.ChainType.EVM:
                return (0, exports.parseEvmChain)(chain);
            case types_1.ChainType.Cosmos:
                return (0, exports.parseCosmosChain)(chain);
        }
    });
    return chains;
};
exports.parseChainData = parseChainData;
const parseChainsResponse = (response) => {
    const chainsResponse = {
        chains: (0, exports.parseChainData)(response.chains)
    };
    return chainsResponse;
};
exports.parseChainsResponse = parseChainsResponse;
//# sourceMappingURL=chains.js.map