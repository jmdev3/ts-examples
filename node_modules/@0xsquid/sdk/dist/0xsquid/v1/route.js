"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRouteResponse = exports.parseParams = exports.parseCustomContractCall = exports.parseTransactionRequest = exports.parseEstimate = exports.parseGasCost = exports.parseFeeCost = exports.parseOptimalRoute = exports.parseRoute = exports.parseCustom = exports.parseSwap = exports.parseBridge = void 0;
const types_1 = require("../../types");
const util_1 = require("./util");
const tokens_1 = require("./tokens");
const utils_1 = require("../../utils");
const parseBridge = (data) => {
    const { fromToken, toToken, fromAmount, toAmount, toAmountMin, exchangeRate, priceImpact } = data;
    return {
        type: types_1.CallType.BRIDGE,
        fromToken,
        toToken,
        fromAmount,
        toAmount,
        toAmountMin,
        exchangeRate,
        priceImpact
    };
};
exports.parseBridge = parseBridge;
const parseSwap = (data) => {
    const { type, dex: { chainName, dexName, factory, isStable, swapRouter }, path, squidCallType, fromToken, toToken, fromAmount, toAmount, toAmountMin, exchangeRate, priceImpact, dynamicSlippage } = data;
    return (0, util_1.removeEmpty)({
        type,
        dex: { chainName, dexName, factory, isStable, swapRouter },
        squidCallType,
        path,
        fromToken,
        toToken,
        fromAmount,
        toAmount,
        toAmountMin,
        exchangeRate,
        priceImpact,
        dynamicSlippage
    });
};
exports.parseSwap = parseSwap;
const parseCustom = (data) => {
    const { type, callType, target, value, callData, estimatedGas, payload } = data;
    return (0, util_1.removeEmpty)({
        type,
        callType,
        target,
        value,
        callData,
        estimatedGas,
        payload
    });
};
exports.parseCustom = parseCustom;
const parseRoute = (data) => {
    const calls = data
        .filter((call) => [types_1.CallType.BRIDGE, types_1.CallType.CUSTOM, types_1.CallType.SWAP].includes(call.type))
        .map((call) => {
        switch (call.type) {
            case types_1.CallType.BRIDGE:
                return (0, exports.parseBridge)(call);
            case types_1.CallType.SWAP:
                return (0, exports.parseSwap)(call);
            case types_1.CallType.CUSTOM:
                return (0, exports.parseCustom)(call);
        }
    });
    return calls;
};
exports.parseRoute = parseRoute;
const parseOptimalRoute = (data) => {
    const { fromChain, toChain } = data;
    const routeData = {
        fromChain: (0, exports.parseRoute)(fromChain),
        toChain: (0, exports.parseRoute)(toChain)
    };
    return routeData;
};
exports.parseOptimalRoute = parseOptimalRoute;
const parseFeeCost = (data) => data.map((item) => {
    return {
        name: item.name,
        description: item.description,
        percentage: item.percentage,
        token: (0, tokens_1.parseTokenData)(item.token),
        amount: item.amount,
        amountUSD: item.amountUSD
    };
});
exports.parseFeeCost = parseFeeCost;
const parseGasCost = (data) => data.map((item) => {
    const { type, token, amount, amountUSD, gasPrice, maxFeePerGas, maxPriorityFeePerGas, estimate, limit } = item;
    return {
        type,
        token: (0, tokens_1.parseTokenData)(token),
        amount,
        amountUSD,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        estimate,
        limit
    };
});
exports.parseGasCost = parseGasCost;
const parseEstimate = (data) => {
    const { fromAmount, sendAmount, toAmount, toAmountMin, fromAmountUSD, toAmountUSD, route, exchangeRate, estimatedRouteDuration, aggregatePriceImpact, feeCosts, gasCosts, isExpressSupported } = data;
    const estimate = {
        fromAmount,
        sendAmount,
        toAmount,
        toAmountMin,
        fromAmountUSD,
        toAmountUSD,
        route: (0, exports.parseOptimalRoute)(route),
        exchangeRate,
        estimatedRouteDuration,
        aggregatePriceImpact,
        feeCosts: (0, exports.parseFeeCost)(feeCosts),
        gasCosts: (0, exports.parseGasCost)(gasCosts),
        isExpressSupported
    };
    return estimate;
};
exports.parseEstimate = parseEstimate;
const parseTransactionRequest = (request) => {
    const { routeType, targetAddress, data, value, gasLimit, gasPrice, gasCosts, maxFeePerGas, maxPriorityFeePerGas } = request;
    return {
        routeType,
        targetAddress,
        data,
        value,
        gasLimit,
        gasPrice,
        gasCosts,
        maxFeePerGas,
        maxPriorityFeePerGas
    };
};
exports.parseTransactionRequest = parseTransactionRequest;
const parseCustomContractCall = (data) => {
    const { callType, target, value, callData, estimatedGas } = data;
    return (0, util_1.removeEmpty)({
        callType,
        target,
        value,
        callData,
        payload: data.payload ? data.payload : undefined,
        estimatedGas
    });
};
exports.parseCustomContractCall = parseCustomContractCall;
const parseParams = (data) => {
    const { fromChain, toChain, fromToken, fromAmount, toToken, toAddress, slippage, quoteOnly, //optional
    enableExpress //optional
     } = data;
    return (0, util_1.removeEmpty)({
        fromChain,
        toChain,
        fromAmount,
        fromToken: (0, tokens_1.parseTokenData)(fromToken),
        toToken: (0, tokens_1.parseTokenData)(toToken),
        toAddress,
        slippage,
        quoteOnly,
        enableExpress: enableExpress ? enableExpress : undefined,
        customContractCalls: data.customContractCalls
            ? (0, exports.parseCustomContractCall)(data.customContractCalls)
            : undefined
    });
};
exports.parseParams = parseParams;
const parseRouteResponse = (response, headers) => {
    const { route: { estimate, transactionRequest, params } } = response;
    const routeResponse = (0, util_1.removeEmpty)({
        ...(0, utils_1.getHeaderTracker)(headers),
        route: {
            estimate: (0, exports.parseEstimate)(estimate),
            transactionRequest: transactionRequest
                ? (0, exports.parseTransactionRequest)(transactionRequest)
                : undefined,
            params: (0, exports.parseParams)(params)
        }
    });
    return routeResponse;
};
exports.parseRouteResponse = parseRouteResponse;
//# sourceMappingURL=route.js.map