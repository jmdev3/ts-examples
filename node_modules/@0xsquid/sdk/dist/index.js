"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Squid = void 0;
const axios_1 = __importDefault(require("axios"));
const ethers_1 = require("ethers");
const route_1 = require("./0xsquid/v1/route");
const sdk_info_1 = require("./0xsquid/v1/sdk-info");
const status_1 = require("./0xsquid/v1/status");
const erc20_json_1 = __importDefault(require("./abi/erc20.json"));
const constants_1 = require("./constants");
const error_1 = require("./error");
const utils_1 = require("./utils");
const setAxiosInterceptors_1 = require("./utils/setAxiosInterceptors");
const baseUrl = "https://testnet.api.0xsquid.com/";
class Squid {
    constructor(config = {}) {
        this.initialized = false;
        this.tokens = [];
        this.chains = [];
        this.isInMaintenanceMode = false;
        this.axiosInstance = (0, setAxiosInterceptors_1.setAxiosInterceptors)(axios_1.default.create({
            baseURL: config?.baseUrl || baseUrl,
            headers: {
                // 'api-key': config.apiKey
                "x-integrator-id": "squid-sdk"
            }
        }), config);
        this.config = {
            baseUrl: config?.baseUrl || baseUrl,
            ...config
        };
    }
    validateInit() {
        if (!this.initialized) {
            throw new error_1.SquidError({
                message: "SquidSdk must be initialized! Please call the SquidSdk.init method",
                errorType: error_1.ErrorType.InitError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
    }
    async validateBalanceAndApproval({ fromTokenContract, fromAmount, fromIsNative, targetAddress, fromProvider, fromChain, signer, infiniteApproval, overrides }) {
        const _sourceAmount = ethers_1.ethers.BigNumber.from(fromAmount);
        let address;
        if (signer && ethers_1.ethers.Signer.isSigner(signer)) {
            address = await signer.getAddress();
        }
        else {
            address = signer.address;
        }
        if (!fromIsNative) {
            const balance = await fromTokenContract.balanceOf(address);
            if (_sourceAmount.gt(balance)) {
                throw new error_1.SquidError({
                    message: `Insufficient funds for account: ${address} on chain ${fromChain.chainId}`,
                    errorType: error_1.ErrorType.ValidationError,
                    logging: this.config.logging,
                    logLevel: this.config.logLevel
                });
            }
            const allowance = await fromTokenContract.allowance(address, targetAddress);
            if (_sourceAmount.gt(allowance)) {
                let amountToApprove = ethers_1.ethers.BigNumber.from(constants_1.uint256MaxValue);
                if (infiniteApproval === false) {
                    amountToApprove = _sourceAmount;
                }
                if (this.config?.executionSettings?.infiniteApproval === false &&
                    !infiniteApproval) {
                    amountToApprove = ethers_1.ethers.BigNumber.from(constants_1.uint256MaxValue);
                }
                const approveTx = await fromTokenContract
                    .connect(signer)
                    .approve(targetAddress, amountToApprove, overrides);
                await approveTx.wait();
            }
        }
        else {
            const balance = await fromProvider.getBalance(address);
            if (_sourceAmount.gt(balance)) {
                throw new error_1.SquidError({
                    message: `Insufficient funds for account: ${address} on chain ${fromChain.chainId}`,
                    errorType: error_1.ErrorType.ValidationError,
                    logging: this.config.logging,
                    logLevel: this.config.logLevel
                });
            }
        }
    }
    validateRouteParams(params) {
        const { fromChain, toChain, fromToken, toToken } = params;
        const _fromChain = (0, utils_1.getChainData)(this.chains, params.fromChain);
        if (!_fromChain) {
            throw new error_1.SquidError({
                message: `fromChain not found for ${fromChain}`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const _toChain = (0, utils_1.getChainData)(this.chains, toChain);
        if (!_toChain) {
            throw new error_1.SquidError({
                message: `toChain not found for ${fromChain}`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const fromProvider = new ethers_1.ethers.providers.JsonRpcProvider(_fromChain.rpc);
        const fromIsNative = fromToken.address === constants_1.nativeTokenConstant;
        let fromTokenContract;
        if (!fromIsNative) {
            fromTokenContract = new ethers_1.ethers.Contract(fromToken.address, erc20_json_1.default, fromProvider);
        }
        return {
            fromChain: _fromChain,
            toChain: _toChain,
            fromToken,
            toToken,
            fromTokenContract,
            fromProvider,
            fromIsNative
        };
    }
    validateTransactionRequest(transactionRequest) {
        if (!transactionRequest) {
            throw new error_1.SquidError({
                message: `transactionRequest param not found in route object`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        return transactionRequest;
    }
    async init() {
        const response = await this.axiosInstance.get("/v1/sdk-info");
        if (response.status != 200) {
            throw new error_1.SquidError({
                message: `SDK initialization failed`,
                errorType: error_1.ErrorType.InitError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const typeResponse = (0, sdk_info_1.parseSdkInfoResponse)(response.data);
        this.tokens = typeResponse.tokens;
        this.chains = typeResponse.chains;
        this.axelarscanURL = typeResponse.axelarscanURL;
        this.isInMaintenanceMode = typeResponse.isInMaintenanceMode;
        this.maintenanceMessage = typeResponse.maintenanceMessage;
        this.initialized = true;
    }
    setConfig(config) {
        this.axiosInstance = axios_1.default.create({
            baseURL: config.baseUrl || baseUrl,
            headers: {
                // 'api-key': config.apiKey
                ...(config.integratorId && { "x-integrator-id": config.integratorId })
            }
        });
        this.config = config;
    }
    async getRoute(params) {
        this.validateInit();
        const response = await this.axiosInstance.get("/v1/route", { params });
        if (response.status != 200) {
            response.data.error;
            throw new error_1.SquidError({
                message: response.data.error,
                errorType: error_1.ErrorType.RouteResponseError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const route = (0, route_1.parseRouteResponse)(response.data, response.headers);
        return route;
    }
    async executeRoute({ signer, route, executionSettings, overrides }) {
        this.validateInit();
        if (!route.transactionRequest) {
            throw new error_1.SquidError({
                message: `transactionRequest property is missing in route object`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const { transactionRequest, params } = route;
        const { fromIsNative, fromChain, fromTokenContract, fromProvider } = this.validateRouteParams(route.params);
        const { targetAddress, maxFeePerGas, maxPriorityFeePerGas, gasPrice, gasLimit } = route.transactionRequest;
        let _gasParams = {};
        if (executionSettings?.setGasPrice) {
            _gasParams = maxPriorityFeePerGas
                ? { maxFeePerGas, maxPriorityFeePerGas, gasLimit }
                : { gasPrice, gasLimit };
        }
        else {
            _gasParams = { gasLimit };
        }
        let _overrides = overrides
            ? { ..._gasParams, ...overrides }
            : { ..._gasParams };
        if (_overrides.gasLimit) {
            _overrides = {
                ..._overrides,
                gasLimit: ethers_1.BigNumber.from(_overrides.gasLimit)
            };
        }
        if (!fromIsNative) {
            await this.validateBalanceAndApproval({
                fromTokenContract: fromTokenContract,
                targetAddress,
                fromProvider,
                fromIsNative,
                fromAmount: params.fromAmount,
                fromChain,
                infiniteApproval: executionSettings?.infiniteApproval,
                signer,
                overrides: _overrides
            });
        }
        const value = ethers_1.ethers.BigNumber.from(route.transactionRequest.value);
        let tx = {
            to: targetAddress,
            data: transactionRequest.data,
            ..._overrides
        };
        if (transactionRequest.routeType !== "SEND") {
            tx = {
                ...tx,
                value
            };
        }
        return await signer.sendTransaction(tx);
    }
    getRawTxHex({ nonce, route, overrides, executionSettings }) {
        if (!route.transactionRequest) {
            throw new error_1.SquidError({
                message: `transactionRequest property is missing in route object`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const { gasLimit, gasPrice, targetAddress, data, maxPriorityFeePerGas, maxFeePerGas, value } = route.transactionRequest;
        let _gasParams = {
            gasLimit: ethers_1.BigNumber.from(gasLimit)
        };
        if (executionSettings?.setGasPrice) {
            _gasParams = maxPriorityFeePerGas
                ? {
                    ..._gasParams,
                    maxFeePerGas: ethers_1.BigNumber.from(maxFeePerGas),
                    maxPriorityFeePerGas: ethers_1.BigNumber.from(maxPriorityFeePerGas)
                }
                : { ..._gasParams, gasPrice: ethers_1.BigNumber.from(gasPrice) };
        }
        else {
            _gasParams = { ..._gasParams, gasPrice: ethers_1.BigNumber.from(gasPrice) };
        }
        const _overrides = overrides
            ? { ..._gasParams, ...overrides }
            : { ..._gasParams };
        return ethers_1.ethers.utils.serializeTransaction({
            chainId: parseInt(route.params.fromChain),
            to: targetAddress,
            data: data,
            value: ethers_1.BigNumber.from(value),
            nonce,
            ..._overrides
        });
    }
    async isRouteApproved({ route, sender }) {
        this.validateInit();
        const { fromIsNative, fromChain, fromProvider, fromTokenContract } = this.validateRouteParams(route.params);
        const { targetAddress } = this.validateTransactionRequest(route.transactionRequest);
        const { params: { fromAmount } } = route;
        const amount = ethers_1.ethers.BigNumber.from(fromAmount);
        if (!fromIsNative) {
            const balance = await fromTokenContract.balanceOf(sender);
            if (amount.gt(balance)) {
                throw new error_1.SquidError({
                    message: `Insufficient funds for account: ${sender} on chain ${fromChain.chainId}`,
                    errorType: error_1.ErrorType.ValidationError,
                    logging: this.config.logging,
                    logLevel: this.config.logLevel
                });
            }
            const allowance = await fromTokenContract.allowance(sender, targetAddress);
            if (amount.gt(allowance)) {
                throw new error_1.SquidError({
                    message: `Insufficient allowance for contract: ${targetAddress} on chain ${fromChain.chainId}`,
                    errorType: error_1.ErrorType.ValidationError,
                    logging: this.config.logging,
                    logLevel: this.config.logLevel
                });
            }
            return {
                isApproved: true,
                message: `User has approved Squid to use ${fromAmount} of ${await fromTokenContract.symbol()}`
            };
        }
        else {
            const balance = await fromProvider.getBalance(sender);
            if (amount.gt(balance)) {
                throw new error_1.SquidError({
                    message: `Insufficient funds for account: ${sender} on chain ${fromChain.chainId}`,
                    errorType: error_1.ErrorType.ValidationError,
                    logging: this.config.logging,
                    logLevel: this.config.logLevel
                });
            }
            return {
                isApproved: true,
                message: `User has the expected balance ${fromAmount} of ${fromChain.nativeCurrency.symbol}`
            };
        }
    }
    async approveRoute({ route, signer, executionSettings, overrides = {} }) {
        this.validateInit();
        const { fromIsNative, fromTokenContract } = this.validateRouteParams(route.params);
        const { targetAddress } = this.validateTransactionRequest(route.transactionRequest);
        const { params: { fromAmount } } = route;
        if (fromIsNative) {
            return true;
        }
        let amountToApprove = ethers_1.ethers.BigNumber.from(constants_1.uint256MaxValue);
        if (executionSettings?.infiniteApproval === false) {
            amountToApprove = ethers_1.ethers.BigNumber.from(fromAmount);
        }
        const approveTx = await fromTokenContract
            .connect(signer)
            .approve(targetAddress, amountToApprove, overrides);
        await approveTx.wait();
        return true;
    }
    async allowance({ owner, spender, tokenAddress, chainId }) {
        this.validateInit();
        const token = (0, utils_1.getTokenData)(this.tokens, tokenAddress, chainId);
        if (!token) {
            throw new error_1.SquidError({
                message: `Token not found for ${tokenAddress}`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const chain = (0, utils_1.getChainData)(this.chains, token.chainId);
        if (!chain) {
            throw new error_1.SquidError({
                message: `Chain not found for ${token.chainId}`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(chain.rpc);
        const contract = new ethers_1.ethers.Contract(token.address, erc20_json_1.default, provider);
        return await contract.allowance(owner, spender);
    }
    async approve({ signer, spender, tokenAddress, amount, chainId, overrides }) {
        this.validateInit();
        const token = (0, utils_1.getTokenData)(this.tokens, tokenAddress, chainId);
        if (!token) {
            throw new error_1.SquidError({
                message: `Token not found for ${tokenAddress}`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const chain = (0, utils_1.getChainData)(this.chains, token.chainId);
        if (!chain) {
            throw new error_1.SquidError({
                message: `Chain not found for ${token.chainId}`,
                errorType: error_1.ErrorType.ValidationError,
                logging: this.config.logging,
                logLevel: this.config.logLevel
            });
        }
        const contract = new ethers_1.ethers.Contract(token.address, erc20_json_1.default, signer);
        return await contract.approve(spender, amount || constants_1.uint256MaxValue, overrides);
    }
    async getStatus(params) {
        const response = await this.axiosInstance.get("/v1/status", {
            params,
            headers: {
                ...(this.axiosInstance.defaults.headers.common &&
                    this.axiosInstance.defaults.headers.common),
                ...(params.requestId && { "x-request-id": params.requestId }),
                ...(params.integratorId && { "x-integrator-id": params.integratorId })
            }
        });
        const statusResponse = (0, status_1.parseStatusResponse)(response, response.headers);
        return statusResponse;
    }
    async getTokenPrice({ tokenAddress, chainId }) {
        const response = await this.axiosInstance.get("/v1/token-price", {
            params: { tokenAddress, chainId }
        });
        return response.data.price;
    }
}
exports.Squid = Squid;
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map